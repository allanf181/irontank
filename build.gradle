buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
        classpath 'com.moowork.gradle:gradle-node-plugin:0.10'
        classpath 'org.ajoberstar:gradle-git:1.3.0'
    }
}

apply plugin: 'forge'
apply plugin: 'curseforge'
apply plugin: 'com.moowork.node'

import org.ajoberstar.grgit.*
import java.util.regex.Pattern

ext.repo = Grgit.open(project.file('.'))
loadProperties()

version = project.mcversion + '-' + version_major + '.' + version_minor + '.' + version_patch + '.' + getBuildNumber()
if (project.buildQualifier != 'release') {
	version = project.version + '-' + project.buildQualifier
}
group= "com.indemnity83.irontank"
archivesBaseName = "irontank"

minecraft {
    version = project.mcversion + "-" + project.forgeversion
    runDir = "eclipse"

    replace '@VERSION@', version_major + '.' + version_minor + '.' + version_patch
    replace '@BUILD_NUMBER@', getBuildNumber()
}

curse.enabled = isInteresting()
curse {
    projectId = '236226'
    apiKey = "${System.getenv().CURSE_API_KEY}"
    releaseType = project.buildQualifier
    changelog = repo.log(maxCommits: 1).fullMessage.get(0)
    relatedProject 'buildcraft'
}

repositories {
    ivy {
        name "BuildCraft"
        artifactPattern "http://www.mod-buildcraft.com/releases/BuildCraft/[revision]/[module]-[revision]-[classifier].[ext]"
    }
    maven {
        name "Mobius Repo"
        url "http://mobiusstrip.eu/maven"
    }
    maven {
      name = "chickenbones"
      url = "http://chickenbones.net/maven/"
    }
}

dependencies {
    // Buildcraft
    compile name: "buildcraft", version: "7.1.6", classifier: "dev"

    // NEI
    compile "codechicken:CodeChickenLib:1.7.10-1.1.3.140:dev"
    compile "codechicken:CodeChickenCore:1.7.10-1.0.7.47:dev"
    compile "codechicken:NotEnoughItems:1.7.10-1.0.5.111:dev"
    compile "codechicken:NotEnoughItems:1.7.10-1.0.5.111:src"

    // Waila
    compile "mcp.mobius.waila:Waila:1.5.10_1.7.10"
}

processResources
{
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        // replace version and mcversion
        expand 'version':version_major + '.' + version_minor + '.' + version_patch + '.' + getBuildNumber(), 'mcversion':project.minecraft.version
    }

    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

node {
    version = '0.12.7'
    download = true
}

def nodeBin = '.' + File.separator + 'node_modules' + File.separator + '.bin' + File.separator
def conventionalChangelog = nodeBin + 'conventional-changelog'
def conventionalRecommendedBump = nodeBin + 'conventional-recommended-bump'


task installConventionalChangelog(type: NpmTask) {
    dependsOn nodeSetup

    outputs.upToDateWhen {
      return file(conventionalChangelog).exists()
    }

    args = ['install', 'conventional-changelog']
}

task installConventionalRecommendedBump(type: NpmTask) {
    dependsOn nodeSetup

    outputs.upToDateWhen {
      return file(conventionalChangelog).exists()
    }

    args = ['install', 'conventional-recommended-bump']
}

task generateChangelog(type:Exec) {
    dependsOn installConventionalChangelog
    executable = new File(conventionalChangelog)
    def argsList = ["-p", "angular", "-i", "CHANGELOG.md", "-w", "-r", "0"]
    args = argsList
}

task recommendBump(type:Exec) {
    dependsOn installConventionalRecommendedBump
    executable = new File(conventionalRecommendedBump)
    def argsList = ["-p", "angular"]
    args = argsList
}

def loadProperties() {
	println('loading application.properties')

	file("application.properties").withReader { reader ->
		def userProps = new Properties()
		userProps.load(reader)

		for (Map.Entry property in userProps) {
			project.ext[property.getKey()] = property.getValue()
		}
	}

  project.ext["buildQualifier"] = "beta"

	def String branch = getBranch()
    if (branch == "master") {
      project.ext["buildQualifier"] = "release"
    }

    if (branch == "release" || branch == "support") {
      project.ext["buildQualifier"] = "alpha"
    }
}

def getBuildNumber() {
	return "$System.env.BUILD_NUMBER" != "null" ? "$System.env.BUILD_NUMBER" : "${repo.head().abbreviatedId}"
}

def getBranch() {
    return "$System.env.BUILD_BRANCH" != "null" ? "$System.env.BUILD_BRANCH" : "${repo.getBranch().getCurrent().getName()}"
}

def saveVersion() {
	ant.propertyfile(
		file: "application.properties") {
		entry( key:"version_major", type:"int", value: version_major)
		entry( key:"version_minor", type:"int", value: version_minor)
		entry( key:"version_patch", type:"int", value: version_patch)
	}
	project.version = version_major + '.' + version_minor + '.' + version_patch + '.' + getBuildNumber()
	printNextVersion()
}

def printNextVersion() {
	println '*************************************************************'
	println 'The next build will be version: ' +  project.version
	println '*************************************************************'
}

task bumpMajor << {
	project.version_major = Integer.parseInt(project.version_major) + 1
	project.version_minor = "0"
	project.version_patch = "0"
	saveVersion()
}

task bumpMinor << {
	project.version_minor = Integer.parseInt(project.version_minor) + 1
	project.version_patch = "0"
	saveVersion()
}

task bumpPatch << {
	project.version_patch = Integer.parseInt(project.version_patch) + 1
	saveVersion()
}

task echoVersion << {
	printNextVersion()
}

task echoLastChange << {
  println repo.log(maxCommits: 1).fullMessage.get(0)
}

def isInteresting() {
  def String log = repo.log(maxCommits: 1).fullMessage.get(0).toString()
  if (log.startsWith("fix") || log.startsWith("feat")) {
    println "commit is \"${repo.log(maxCommits: 1).shortMessage.get(0).toString()}\", that sounds interesting..."
    return true
  }

  if (log.contains("BREAKING")) {
    println "commit lists a breaking change, this is interesting..."
    return true
  }

  def String branch = getBranch()
  if (branch == "master" || branch.startsWith("release")) {
    println "building " + getBranch() + ", this is interesting..."
    return true
  }

  println "Build is boring"
  return false
}
